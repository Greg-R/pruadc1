%    Documentation for PRU ADC Project
%    Copyright (C) 2016  Gregory Raven
%
%    This program is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program.  If not, see <http://www.gnu.org/licenses/>.

\chapter{PRU Firmware and User-space Program}

The ``PRU Firmware'' are two binary files which are placed in the directory /lib/firmware.
These files must have specific names as follows:

\begin{itemize}
	\item am335x-pru0-fw
	\item am335x-pru1-fw
\end{itemize}

The Makefile includes cp commands to copy the firmwares to the /lib/firmware directory.

\section{Implementing the SPI Bus in C}

The SPI bus C program roughly follows the PRU assembly code written by Derek Molloy.  The C code is compiled to a binary file am335x-pru0-fw. The firmware is loaded into PRU0 automatically by the remoteproc kernel driver.

The program begins with code sequestered from the example code files in TI's PRU Software
Support Package.  This codes establishes the character device driver via the ``Remote Proc Messenger''
kernel driver.  There is a sort of ``priming'' process required whereby a user space program writes
to the device driver.  The initializes the character driver, which allows it to write data from
the PRU to the character driver and thus making the data available in user-space.

After the initialization is complete, the program enters a for loop.  The SPI bus is implemented inside this for loop.  This is done by bit-banging the GPIOs which have been connected to PRU0 via the Universal IO.  Each pass through the for loop captures a single 10-bit sample from the ADC.

The samples are accumulated in a buffer.  When the buffer is filled, the data is written to the character device via a function provided by the RPMsg kernel driver.

Timings are critical, and this was accomplished by using the compiler intrinsic \_\_delay\_cycles.  Each delay is an absolute value of 5 nanoseconds.  This scheme appears to produce accurate enough timing to implement the SPI bus in real time.  

\section{Implementing the Timing Clock in C}

The ``Timing Clock'' sets the data sample rate.  The code is compiled into firmware am335x-pru1-fw, and this binary file is loaded into PRU1 by the Remoteproc kernel driver.

The output of the Timing Clock is a simple pulse at a rate of 8 kHz.  This pulse is written to a PRU shared memory location.  This means that the SPI PRU0 can access this memory address and read its state.  A while loop in PRU0 polls this address and exits from the loop when the pulse goes high.  This polling action is done at the top of the for loop which captures a data sample from the ADC.  Thus the data capturing sequence in PRU0 is gated at the Timing Clock pulse rate.

The Timing Clock does not begin emitting pulses as soon as the firmware is loaded and started.  There is a character device created in the initialization section of the C code.  The character device is created, and then a while loop begins monitoring for a specific incoming message, which in this case is the letter ``g'' (go);  When the go message is successfully received, the while loop is exited and the Timing Clock pulse code begins emitting pulses to PRU shared memory.


